"use strict"; function Peer(e, n, r, t, i, c) { var o = new RTCPeerConnection(e); function a(e) { var n = ["Bytes", "KB", "MB", "GB", "TB"]; if (e <= 0) return "0 Bytes"; var r = parseInt(Math.floor(Math.log(e) / Math.log(1e3)), 10); return n[r] ? (e / Math.pow(1e3, r)).toPrecision(3) + " " + n[r] : "0 Bytes" } o.id = n, c.enabled && getStats(o, function (e) { c.onStats(function (e, n, r) { if (1 === r) { -1 !== n.connectionType.remote.candidateType.indexOf("relayed") ? n.connectionType.remote.candidateType = "TURN" : n.connectionType.remote.candidateType = "STUN"; var t = {}; return t.remoteIceType = n.connectionType.remote.candidateType, t.externalIPAddressRemote = n.connectionType.remote.ipAddress.join(", "), t.remoteTransport = n.connectionType.remote.transport.join(", "), -1 !== n.connectionType.local.candidateType.indexOf("relayed") ? n.connectionType.local.candidateType = "TURN" : n.connectionType.local.candidateType = "STUN", t.ocalIceType = n.connectionType.local.candidateType, t.externalIPAddressLocal = n.connectionType.local.ipAddress.join(", "), t.localTransport = n.connectionType.local.transport.join(", "), t.encryptedAs = n.encryption, t.videoResolutionsForSenders = n.resolutions.send.width + "x" + n.resolutions.send.height, t.videoResolutionsForReceivers = n.resolutions.recv.width + "x" + n.resolutions.recv.height, t.totalDataForSenders = a(n.audio.bytesSent + n.video.bytesSent), t.totalDataForReceivers = a(n.audio.bytesReceived + n.video.bytesReceived), t.codecsSend = n.audio.send.codecs.concat(n.video.send.codecs).join(", "), t.codecsRecv = n.audio.recv.codecs.concat(n.video.recv.codecs).join(", "), t.bandwidthSpeed = a(n.bandwidth.speed), !0 === n.ended && n.nomore(), t } return n }(0, e, c.level)) }, c.interval), o.onnegotiationneeded = i, o.ontrack = function (e) { let { transceiver: n, streams: [r] } = e, i = null; o.getTransceivers().forEach(e => { e.mid == n.mid && (i = e) }), t(o.id, i, r) }, o.onicecandidate = function (e) { if (e.candidate) { var n = { sdpMLineIndex: e.candidate.sdpMLineIndex, sdpMid: e.candidate.sdpMid, candidate: e.candidate.candidate }, t = JSON.stringify(n); r(t) } }, this.close = function () { o.close() }, this.addLocalStream = function (e, n, r = null) { var t = e; e.pc = e.pc || {}, e.pc[o.id] = e.pc[o.id] || {}, e.pc[o.id].transceivers = e.pc[o.id].transceivers || [], t.getTracks().forEach(i => { if (n == i.kind || !n) { let n = o.addTransceiver(i, { streams: [t] }); n.mediaName = r, e.pc[o.id].transceivers.push(n) } }) }, this.removeLocalStream = function (e) { e.pc && e.pc[o.id].transceivers.forEach(e => { o.removeTrack(e) }) }, this.removeTrack = function (e) { o.getSenders().forEach(e => { o.removeTrack(e) }), o.getTransceivers().forEach(n => { "sender" == e ? n.direction : "receiver" == e && (n.direction = "senonly") }) }, this.addTrack = function (e, n) { let r = o.getTransceivers(); n && r.every(r => { if (r.sender) { if ("video" == n) return r.sender.replaceTrack(e ? e.getVideoTracks()[0] : null), !1; if ("audio" == n) return r.sender.replaceTrack(e ? e.getAudioTracks()[0] : null), !1 } return !0 }) }, this.isTransceiverExists = function () { return o.getTransceivers().length > 0 }, this.enableDisable = function (e, n) { o.getTransceivers().forEach(r => { e ? r.sender && r.sender.track && r.sender.track.kind == e && (r.sender.track.enabled = n) : r.sender && r.sender.track && (r.sender.track.enabled = n) }) }, this.replaceTrack = function (e, n) { let r = o.getTransceivers(); n ? r.every(r => { if (r.sender && r.sender.track && r.sender.track.kind == n) { if ("video" == n) return r.sender.replaceTrack(e ? e.getVideoTracks()[0] : null), !1; if ("audio" == n) return r.sender.replaceTrack(e ? e.getAudioTracks()[0] : null), !1 } return !0 }) : r.forEach(n => { "video" == n.mediaType ? n.sender.replaceTrack(e.getVideoTracks()[0]) : "audio" == n.mediaType && n.sender.replaceTrack(e.getAudioTracks()[0]) }) }, this.createOffer = function (e) { o.createOffer({ offerToReceiveVideo: !0, offerToReceiveAudio: !0 }).then(n => { o.setLocalDescription(n).then(() => { e(o.id, n.sdp) }) }) }, this.processOfferSdpAndGenerateAnswer = function (e) { var n = $.Deferred(); return e = { sdp: e, type: "offer" }, o.setRemoteDescription(new RTCSessionDescription(e)).then(() => { o.createAnswer().then(e => { o.setLocalDescription(e).then(() => { n.resolve(e.sdp) }) }) }), n }, this.processAnswer = function (e) { return e = { sdp: e, type: "answer" }, o.setRemoteDescription(new RTCSessionDescription(e)) }, this.processICECandidates = function (e) { for (; e.length;) { let n = e.shift(); o.addIceCandidate(new RTCIceCandidate(n)) } } } module.exports.Peer = Peer;